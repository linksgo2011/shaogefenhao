(window.webpackJsonp=window.webpackJsonp||[]).push([[359],{1186:function(t,a,e){"use strict";e.r(a);var r=e(15),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("缓存方案已经很成熟，可以参考相关的文章做技术选型。但是缓存策略比较麻烦，需要专门做一些处理。")]),t._v(" "),e("h2",{attrs:{id:"根据-ddd-分层设计缓存策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#根据-ddd-分层设计缓存策略"}},[t._v("#")]),t._v(" 根据 DDD 分层设计缓存策略")]),t._v(" "),e("p",[t._v("参考 DDD 分层思想进行缓存更新策略的设计：")]),t._v(" "),e("ol",[e("li",[t._v("接入层缓存 - 在用例上做缓存，简单粗暴，使用的人也多，但是粒度太大，不是很好进行缓存 evict")]),t._v(" "),e("li",[t._v("领域层缓存\n"),e("ul",[e("li",[t._v("使用 JPA 对象做 unproxy 进行缓存，unproxy 有点像把领域模型转换层查询模型 ✅")]),t._v(" "),e("li",[t._v("使用 CQRS，将查询模型和领域模型分开处理，只是缓存查询模型")])])]),t._v(" "),e("li",[t._v("基础设施层缓存，使用 JPA hibernate 缓存（hibernate-ehcache，无需使用 unproxy）")])]),t._v(" "),e("h2",{attrs:{id:"使用的缓存的注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用的缓存的注意事项"}},[t._v("#")]),t._v(" 使用的缓存的注意事项")]),t._v(" "),e("ol",[e("li",[t._v("只在高频查询接口中使用缓存，所有为更新的查询不能使用缓存 (甚至可以使用 findForUpdate 这种专门的语句更新 JPA)")]),t._v(" "),e("li",[t._v("缓存只是存放到无 proxy 的领域模型和查询对象上")]),t._v(" "),e("li",[t._v("不缓存列表页，命中率太低，如果需要继续性能提升，直接配置读库即可，只是缓存热点 hash 数据。如果读库的查询性能不能满足，可以使用 ElasticSearch。")])]),t._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("ul",[e("li",[t._v("Redis 多条件组合的查询列表页，大家怎么做缓存 https://ruby-china.org/topics/10211")]),t._v(" "),e("li",[t._v("缓存那些事 https://tech.meituan.com/2017/03/17/cache-about.html")])])])}),[],!1,null,null,null);a.default=s.exports}}]);